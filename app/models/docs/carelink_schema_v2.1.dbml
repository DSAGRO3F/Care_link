// ============================================================================
// CARELINK - SCHÉMA DE BASE DE DONNÉES
// Version: 2.1
// Date: Décembre 2024
// Changements: Ajout patient_documents et coordination_entries
// ============================================================================

// === NIVEAU 1 : GÉOGRAPHIE ===
Table countries {
  id integer [pk]
  name varchar [not null, note: 'Nom du pays (France, Belgique, Suisse...)']
  country_code varchar [unique, not null, note: 'Code ISO 3166-1 alpha-2 (FR, BE, CH...)']
  created_at timestamp [note: 'Date de création']
  updated_at timestamp [note: 'Date de dernière modification']
  status varchar [default: 'active', note: 'active, inactive']
}

// === NIVEAU 2 : ENTITÉS DE SOINS ===
Table entities {
  id integer [pk]
  name varchar [not null, note: 'Nom de la structure']
  entity_type varchar [not null, note: 'SSIAD, EHPAD, SAAD, GCSMS, DAC, CPTS']
  siren varchar [unique, note: 'Numéro SIREN (9 chiffres)']
  finess varchar [unique, note: 'Numéro FINESS établissement']
  country_id integer [ref: > countries.id, not null]
  address varchar [note: 'Adresse postale']
  phone varchar [note: 'Téléphone principal']
  email varchar [note: 'Email de contact']
  created_at timestamp
  updated_at timestamp
  status varchar [default: 'active', note: 'active, inactive, suspended']
}

// === PROFESSIONS (réglementées) ===
Table professions {
  id integer [pk]
  name varchar [unique, not null, note: 'Médecin, Infirmier, Aide-soignant...']
  code varchar [unique, note: 'Code officiel RPPS/ADELI']
  category varchar [note: 'MEDICAL, PARAMEDICAL, ADMINISTRATIF']
  requires_rpps boolean [default: true, note: 'Profession nécessitant un numéro RPPS']
  created_at timestamp
  updated_at timestamp
}

// === RÔLES (fonctionnels dans CareLink) ===
Table roles {
  id integer [pk]
  name varchar [unique, not null, note: 'MEDECIN_TRAITANT, COORDINATEUR, INFIRMIERE...']
  description varchar [note: 'Description du rôle']
  permissions json [note: 'Liste des permissions JSON ["PATIENT_VIEW", "PATIENT_EDIT"...]']
  is_system_role boolean [default: false, note: 'Rôle système non modifiable']
  created_at timestamp
  updated_at timestamp
}

// === UTILISATEURS (Professionnels) ===
Table users {
  id integer [pk]
  email varchar [unique, not null, note: 'Email unique de connexion']
  first_name varchar [not null, note: 'Prénom']
  last_name varchar [not null, note: 'Nom de famille']
  rpps varchar [unique, note: 'Numéro RPPS 11 chiffres (NULL si non soignant)']
  profession_id integer [ref: > professions.id, note: 'Profession réglementée']
  password_hash varchar [note: 'Hash bcrypt du mot de passe (si auth locale)']
  is_admin boolean [default: false, note: 'Administrateur système']
  is_active boolean [default: true, note: 'Compte actif']
  last_login timestamp [note: 'Dernière connexion']
  created_at timestamp
  updated_at timestamp
}

// === JONCTION : Users ↔ Roles (many-to-many) ===
Table user_roles {
  user_id integer [ref: > users.id, not null]
  role_id integer [ref: > roles.id, not null]
  assigned_at timestamp [note: 'Date d attribution du rôle']
  assigned_by integer [ref: > users.id, note: 'Qui a attribué ce rôle']
  
  indexes {
    (user_id, role_id) [pk]
  }
}

// === JONCTION : Users ↔ Entities (many-to-many) ===
Table user_entities {
  id integer [pk]
  user_id integer [ref: > users.id, not null]
  entity_id integer [ref: > entities.id, not null]
  is_primary boolean [default: false, note: 'Entité principale de rattachement']
  contract_type varchar [note: 'SALARIE, LIBERAL, VACATION, REMPLACEMENT']
  start_date date [not null, note: 'Date de début']
  end_date date [note: 'Date de fin (NULL = actif)']
  created_at timestamp
  
  indexes {
    (user_id, entity_id) [unique]
  }
}

// === PATIENTS ===
Table patients {
  id integer [pk]
  
  // Données chiffrées AES-256-GCM (RGPD)
  nir_encrypted varchar [note: 'NIR chiffré (N° Sécurité Sociale)']
  ins_encrypted varchar [note: 'INS chiffré (Identifiant National de Santé)']
  first_name_encrypted varchar [note: 'Prénom chiffré']
  last_name_encrypted varchar [note: 'Nom chiffré']
  birth_date_encrypted varchar [note: 'Date naissance chiffrée']
  address_encrypted varchar [note: 'Adresse chiffrée']
  phone_encrypted varchar [note: 'Téléphone chiffré']
  email_encrypted varchar [note: 'Email chiffré']
  
  // Relations
  medecin_traitant_id integer [ref: > users.id, note: 'Médecin traitant référent']
  entity_id integer [ref: > entities.id, not null, note: 'Structure de rattachement']
  
  // Audit & versioning
  version integer [default: 1, note: 'Version pour optimistic locking']
  created_at timestamp
  updated_at timestamp
  created_by integer [ref: > users.id, note: 'Créé par']
  updated_by integer [ref: > users.id, note: 'Modifié par']
  status varchar [default: 'active', note: 'active, archived, deceased']
}

// === ACCÈS PATIENTS (Traçabilité RGPD) ===
Table patient_access {
  id integer [pk]
  patient_id integer [ref: > patients.id, not null]
  user_id integer [ref: > users.id, not null]
  
  // Type et justification (RGPD obligatoire)
  access_type varchar [not null, note: 'READ, WRITE, FULL']
  reason varchar [not null, note: 'Justification obligatoire RGPD']
  
  // Qui a accordé l accès
  granted_by integer [ref: > users.id, not null]
  granted_at timestamp [not null]
  
  // Durée de validité
  expires_at timestamp [note: 'NULL = permanent']
  revoked_at timestamp [note: 'NULL = actif']
  revoked_by integer [ref: > users.id]
  
  // Note: PAS d index unique pour permettre l historique des accès
  indexes {
    (patient_id, user_id)
  }
}

// === ÉVALUATIONS PATIENT (JSON Schema) ===
Table patient_evaluations {
  id integer [pk]
  patient_id integer [ref: > patients.id, not null]
  evaluator_id integer [ref: > users.id, not null]
  
  // Type et version du schéma
  schema_type varchar [not null, note: 'evaluation_complete, aggir_only, social_only']
  schema_version varchar [not null, note: 'v1, v2...']
  
  // Données d évaluation (JSON validé par JSON Schema)
  evaluation_data jsonb [not null, note: 'Document JSON complet']
  
  // Métadonnées extraites pour requêtes rapides
  gir_score integer [note: 'Score GIR 1-6 extrait du JSON']
  evaluation_date date [not null]
  
  // Validation
  validated_at timestamp [note: 'Date de validation']
  validated_by integer [ref: > users.id, note: 'Validé par']
  
  // Audit & versioning
  version integer [default: 1]
  created_at timestamp
  updated_at timestamp
  
  indexes {
    (patient_id, evaluation_date)
  }
}

// === DOCUMENTS PATIENTS (PPA, PPCS, Recommandations) ===
// Stocke les métadonnées des documents générés par LLM/RAG
// Le fichier binaire (PDF/DOCX) est stocké sur le filesystem/object storage
Table patient_documents {
  id integer [pk]
  patient_id integer [ref: > patients.id, not null]
  
  // Type de document
  document_type varchar [not null, note: 'PPA, PPCS, RECOMMENDATION, OTHER']
  title varchar [not null, note: 'Titre du document']
  description text [note: 'Description ou résumé du contenu']
  
  // Source de génération (traçabilité LLM/RAG)
  source_evaluation_id integer [ref: > patient_evaluations.id, note: 'Évaluation source pour PPA/PPCS']
  generation_prompt text [note: 'Question/prompt envoyé au LLM (pour audit)']
  generation_context jsonb [note: 'Contexte JSON envoyé au LLM (pour reproductibilité)']
  
  // Fichier
  file_path varchar [not null, note: 'Chemin relatif vers le fichier stocké']
  file_format varchar [not null, note: 'pdf, docx']
  file_size_bytes integer [note: 'Taille du fichier en octets']
  file_hash varchar [note: 'Hash SHA-256 du fichier (intégrité)']
  
  // Métadonnées
  generated_at timestamp [not null, note: 'Date/heure de génération']
  generated_by integer [ref: > users.id, not null, note: 'Utilisateur ayant demandé la génération']
  
  // Audit
  created_at timestamp
  updated_at timestamp
  
  indexes {
    (patient_id, document_type)
    (patient_id, generated_at)
  }
}

// === CARNET DE COORDINATION ===
// Traçabilité des interventions pour éviter les doublons
// et assurer la coordination entre professionnels
Table coordination_entries {
  id integer [pk]
  patient_id integer [ref: > patients.id, not null]
  user_id integer [ref: > users.id, not null, note: 'Professionnel ayant réalisé l intervention']
  
  // Catégorisation
  category varchar [not null, note: 'SOINS, HYGIENE, ALIMENTATION, MOBILITE, MEDICAL, SOCIAL, ADMINISTRATIF, OBSERVATION']
  intervention_type varchar [not null, note: 'Type spécifique (toilette, pansement, injection...)']
  
  // Contenu
  description text [not null, note: 'Description de l intervention réalisée']
  observations text [note: 'Observations complémentaires (état du patient, remarques...)']
  next_actions text [note: 'Actions à prévoir pour la prochaine intervention']
  
  // Horodatage
  performed_at timestamp [not null, note: 'Date/heure de réalisation de l intervention']
  duration_minutes integer [note: 'Durée de l intervention en minutes']
  
  // Audit
  created_at timestamp [note: 'Date de saisie dans le système']
  updated_at timestamp
  deleted_at timestamp [note: 'Soft delete pour audit (NULL = actif)']
  
  indexes {
    (patient_id, performed_at)
    (patient_id, category)
    (patient_id, user_id)
  }
}

// === SEUILS PERSONNALISÉS (constantes vitales) - REPORTÉ V2 ===
Table patient_thresholds {
  id integer [pk]
  patient_id integer [ref: > patients.id, not null]
  
  vital_type varchar [not null, note: 'FC, TA_SYS, TA_DIA, SPO2, TEMP, POIDS, GLYCEMIE']
  min_value decimal [note: 'Valeur minimale acceptable']
  max_value decimal [note: 'Valeur maximale acceptable']
  unit varchar [not null, note: 'Unité de mesure']
  surveillance_frequency varchar [note: '1x/jour, 2x/jour, 1x/semaine...']
  
  created_at timestamp
  updated_at timestamp
  
  indexes {
    (patient_id, vital_type) [unique]
  }
}

// === MESURES DE CONSTANTES VITALES - REPORTÉ V2 ===
Table patient_vitals {
  id integer [pk]
  patient_id integer [ref: > patients.id, not null]
  
  // Type de mesure
  vital_type varchar [not null, note: 'FC, TA_SYS, TA_DIA, SPO2, TEMP, POIDS, GLYCEMIE']
  
  // Valeur mesurée
  value decimal [not null, note: 'Valeur numérique']
  unit varchar [not null, note: 'Unité de mesure']
  
  // Comparaison aux seuils
  status varchar [note: 'normal, low, high, critical']
  
  // Source de la mesure
  source varchar [not null, note: 'manual, withings, apple_watch, freestyle_libre']
  device_id integer [ref: > patient_devices.id, note: 'Device source si automatique']
  
  // Horodatage
  measured_at timestamp [not null, note: 'Date/heure de la mesure']
  recorded_by integer [ref: > users.id, note: 'NULL si automatique']
  
  // Métadonnées
  notes text [note: 'Observations']
  created_at timestamp
  updated_at timestamp
  
  indexes {
    (patient_id, vital_type, measured_at)
  }
}

// === DEVICES CONNECTÉS - REPORTÉ V2 ===
Table patient_devices {
  id integer [pk]
  patient_id integer [ref: > patients.id, not null]
  
  device_type varchar [not null, note: 'withings_scale, apple_watch, freestyle_libre']
  device_identifier varchar [not null, note: 'Identifiant unique du device']
  device_name varchar [note: 'Nom donné par le patient']
  
  // Credentials API (chiffrés AES-256-GCM)
  api_credentials_encrypted varchar [note: 'Tokens OAuth chiffrés']
  
  // État
  is_active boolean [default: true]
  last_sync_at timestamp [note: 'Dernière synchronisation']
  
  created_at timestamp
  updated_at timestamp
  
  indexes {
    (patient_id)
    (device_type, device_identifier) [unique]
  }
}
